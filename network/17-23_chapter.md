# 17. 파일 검색

## 17.1 파일 검색
파일 검색은 대표적으로 find와 locate가 있다.

### 17.1.1 locate
locate는 경로명에 대한 빠른 데이터베이스 검색을 수행하고 주어진 조건에 일치하는 모든 이름을 출력한다.  
find보다 쉽다.  

**locate는 매일 주기적으로 db를 업데이트해서 경로를 찾기 때문에 최신 생성 파일 등은 바로 검색되지 않을 수 있다.**

_locate bin/zip_


### 17.1.2 find
개인적으로 이 장의 핵심이라고 생각한다.  
locate는 오로지 파일명에 근거하여 파일을 찾지만 find는 훨씬 더 많은 조건을 기반으로 검색할 수 있다.  

기본 사용은 find와 찾을 대상의 경로를 함께 입력한다.  
_find search-path_  

그리고 여기에 더해 **테스트, 액션, 옵션**을 추가하여 검색 조건을 구체화할 수 있다.

#### 17.1.3. 테스트

테스트 예제 | 설명 
-----|-----
-cmin _n_ | n분 전에 마지막으로 내용이나 속성이 변경된 파일 / 디렉토리 검색
-cnewer _file_ | filㄷ보다 최근에 마지막으로 내용이나 속성이 변경된 파일 / 디렉토리 검색
-ctime _n_ | n * 24 시간 전에 마지막으로 내용이나 속성이 변경된 파일 / 디렉토리 검색
-mmin _n_ | n분 전에 마지막으로 내용이 변경된 파일 / 디렉토리 검색
-mmin _n_ | n분 전에 마지막으로 내용이 변경된 파일 / 디렉토리 검색
-empty | 빈 파일이나 디렉토리 검색
-group _name_ | name 그룹에 속한 파일 / 디렉토리 검색
-name _pattern_ | 지정된 이름이나 와일드카프 패턴과 일치하는 파일 / 디렉토리 검색
-iname _pattern_ | 위와 동일하나 대소문자 구별하지 않음.
-size _n_ | n 크기의 파일 검색
-perm _mode_ |지정된 mode로 퍼미션이 설정된 파일 / 디렉토리 검색
-type _c_ | c 형식의 파일 검색

#### 17.1.3.1 테스트 유형
* 파일 형식 테스트.  
-type을 통해 파일인지, 디렉토리인지 등에 따라 검색을 다르게 할 수 있다.

파일형식 | 설명 
-----|-----
b | 블록 특수 파일
c | 문자 특수 파일
**d** | **디렉토리**
**f**  | **파일**
l | 심볼릭 링크
<br>

* 파일 형식 테스트.  
-size를 통해 사이즈 단위를 지정할 수 있다. +, -를 이용해 이상, 이하를 지정할 수 있다.  

기호 | 크기 단위
-----|-----
b | 512바이트 단위의 블록(기본값)
c | 바이트
**k** | **킬로바이트**
**M**  | **메가바이트**
**G**  | **기가바이트**

ex) `find ~ -type d -name '*.jpg' -size +1M | wc -l`
<br><br>


#### 17.1.4. 연산자
테스트들의 논리적 연산 관계를 정의할 수 있다. 위의 예시에서 각 테스트들은 _-and_ 기본값으로 동작한다.  
기본값이기 때문에 생략 가능하다.  

연산자 | 설명
----|----
-and | 연산자를 기준으로 양쪽 테스트가 모두 참인 경우에 검색
-or | 연산자를 기준으로 양쪽 테스트 중 하나라도 참인 경우에 검색
-not | 이 연산자 다음 테스트가 거짓일 경우에 검색
(  )  | 테스트들을 묶음. 일반 계산식의 괄호와 흡사하다.

ex) `find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)`
다음은 어떤 조건일까?  

참고로 `( )`는 `\`로 이스케이프 해줘야 하며,  
`( )` 바로 뒤나 앞에 글자가 있어서는 안 된다.
<br><BR>


#### 17.1.5. 액션
기존 find의 결과물은 해당 결과물을 보여주는 데 그쳤는데 액션을 통해서 이것들을 가지고 **작업**을 할 수 있다.  
액션은 미리 정의된 액션과 사용자 지정의 액션이 있다.  

##### 17.1.5.1 사용자 정의 액션

액션 | 설명
----|----
-delete | 현재 검색된 파일을 삭제한다. **복구할 수 없으므로 매우 조심.**
-ls | 검색된 파일에 대해서 `ls -dilts`와 같은 명령을 실행. 출력은 표준 출력으로 전송.
-print | 검색 결과의 전체 경로명을 표준 출력으로 출력. **기본값이다.**
-quit | 검색 조건에 부합하는 결과가 하나라도 나올 경우 검색 종료


##### 17.1.5.2 사용자 정의 액션
-exec _command_ {};를 통해 임의의 명령어를 실행할 수도 있다.

ex)  
`-exec rm '{}' ';'`   <-- 여기서 '{}'는 현재 경로명에 대한 심볼릭 링크, ';'는 명령어의 끝을 말해주는 구획기호.
<br><br>

#### 17.1.6. 능률 높이기
이 식을 살펴보자.  
`find ~ -type f -exec ls -l '{}' ';'`  

이 식을 통해서 검색되는 모든 파일에는 `ls -l`이 적용될 것이다.  
그런데 이건 비효율적이다.  
`ls file1`, `ls file2` 이렇게 모든 파일에 ls를 적용하는 것보다는 `ls file1 file2` 이렇게 하면 효율이 좋다.  

이렇게 할 수 있는 방법이 두 가지 있다.

1. `find ~ -type f -exec ls -l '{}' +`처럼 세미콜론 대신 '+'를 사용.
1. `find ~ -type f | xargs ls -l` xargs라는 기능을 사용

* 부록 :  

간혹 파일명에 ' ' 공백을 넣는 사람들이 있는데 이러면 find에서 인자를 공백으로 구분해서  
파일명을 제대로 인식하지 못할 수 있다. 이럴 때는  

`find ~ -type f -print0 | xargs -null ls -l`  

처럼 해서 널문자를 구분자로 출력해서(-print0), 그 널문자를 구분자 입력으로 받아들이는 위와 같은 방식을 쓸 수  있다.


<br><BR><BR>
# 18. 파일 보관 및 백업
파일 압축은 손실과 무손실이 있다.  

손실은 jpeg, mp3가 있다.  
(jpeg와 jpg의 차이는 뭘까?)

여기서는 무손실만 다룬다.  

## 파일 압축하기
---

### gzip
**gzip**은 하나 이상의 파일을 압축한다.  
압축을 풀 때는 **gunzip**을 사용한다.  
gzip을 사용하면 압축파일이 원본 파일과 나란히 생성되는 것이 아니고 **원본을 대체한다.**  

* 유용한 옵션
  - c : stdout에 압축결과를 출력. `>`와 함께 기존 파일을 그대로 두고 압축파일 생성 가능. 
  - d : 압축을 푼다. gzip -d 은 gunzip과 동일어
  - f : force. 압축이 되어 있어도 압축한다.
  - r : 압축 대상이 디렉토리일 경우 필요하다.
  - t : 파일의 무결성을 검사한다.
  - number : 압축 정도를 설정. 1(빠르지만 압축율 최소) ~ 9(느리지만 압축율 최대)까지 설정 가능.	
  <br>
   
gunzip은 압축파일이 `.gz`로 끝날 것이라고 가정하기 때문에 안 적어줘도 된다.   
 
### bzip2
gzip과 유사하지만 **다른 압축 알고리즘을 사용해 속도는 느리지만 높은 압축률을 보유.**  
거의 비슷하며 확장하는 `.bz2`  

압축 해제는 `bunzip2`인데 여기는 gunzip과 달리 압축 풀 때 확장자 `.bz2`를 꼭 명시해야 한다.
<br><BR><BR>


## 파일 보관하기(아카이빙)
파일 압축과 아카이빙은 같이 가야 한다.  
아카이빙이란 많은 파일을 묶어서 하나의 큰 파일로 묶는 과정.  
<br>

### tar
유닉스 세상에서 `tar`는 파일 보관을 위한 전통적인 툴로 **tape archive**의 약자다.  
백업 테이프를 만들기 위한 도구에서 유래되었음.  

.tar : tar 아카이브를 나타내는 확장자  
.tgz : tar 아카이브를 gzip로 압축한 파일임을 나타내는 확장자.  

* tar 모드
  - c: 파일 또는 디렉토리에서 아카이브 생성하기
  - x: 아카이브 해체하기
  - r: 아카이브 끝에 지정된 경로명을 덧붙이기
  - t: 아카이브 내용 보기
  - f : '아카이브를 사용하겠다'를 의미
  - v: verbose. 자세하게 표시.
  
* 아카이브 만들기
`tar cf des src`

* 아카이브 보기
`tar tf tar-file`

* 아카이브 해체
`tar xf tar-file`
<br><BR>

## 파일 및 디렉토리 동기화
### rsync
**원격에서 파일 및 디렉토리 동기화**를 할 수 있는 프로그램이다.  

사용 방법은 다음과 같다.  
_rsync options source destination_  

여기서 source와 destination에는  

* 로컬 파일이나 디렉토리
* 원격 파일이나 디렉토리(remote-user:directory 식으로 사용 가능)
* 원격 rsync 서버  

중 하나가 올 수 있는데 **둘 중 하나는 반드시 로컬**이어야 한다.  
원격지 간의 복사는 지원되지 않는다.

* 옵션
  - -av : source를 destination에 동기화(미러링)
  - --delete : 기존에는 더 이상 없지만 destination에는 남아 있는 파일 삭제
  - --rsh : 원격 쉘을 어떤 쉘을 이용할 것인지를 결정할 수 있다. ssh로 정하면 ssh로 통신 가능.  
  
  !! 직접 해보자
<br><BR><BR>



## 19. 정규 표현식(Regular Expression)
그 유명한 유닉스의 정규 표현식. 이제 시작합니다.  
내가 개인적으로 번역하고 있는 파이썬 공식문서는 [다음](https://github.com/shoark7/Self-learning-contents/blob/master/python/%5BPython%5DRegular-Expression.md)과 같다.  
정규 표현식이란 **텍스트에서 패턴을 인식하는 심볼 표기법**  
확장에서 사용했던 와일드카드 방식과 닮았지만 엄연히 다르며 더 웅장하다.  
<br>

### 19.1. grep - 텍스트를 통한 검색
grep은 `global regular expression print`의 약자.  
텍스트에서 정규 표현식을 통해 특정 텍스트, 단어, 문장만 추출할 수 있다.  

ex) `ls /usr/bin | grep zip`


* grep의 유용한 옵션

옵션 | 설명
-----|----
-i | ignore case. 대소문자를 무시한다.
-v | reverse의 v. **패턴에 포함되지 않는 나머지**를 출력한다.
-c | 일치한 행이 아닌 행의 수를 출력한다. --count와 동일 
-l | 일치한 행 자체가 아닌 이를 포함한 각각의 파일 이름을 출력( grep bzip dirlist*.txt )
-L | -l과 유사하지만 일치하는 행이 없는 파일의 이름만을 출력
-n | 일치하는 행 앞에 파일의 행 번호를 붙인다.
-h | 복수 파일 검색에서, 파일명의 출력을 숨긴다.( grep bzip dirlist*.txt )


### 19.2. 메타문자와 리터럴
`grep bzip ok.txt` 이 간단한 grep 식에도 정규표현식이 포함되었다.  
bzip은 순수한 b, z, i, p 문자순으로, 이렇게 그 자체로 일치되는 것을 상수 문자(literal character)라고 한다.  
정규 표현식은 많은 메타문자들을 포함하며 다음으로 구성된다.  

`^ $ [ ] { } - ? * + ( ) | \`  

비록 `\`, 백슬래쉬 문자는 메타시퀀스를 생성하는 경우에 사용되기는 하지만 나머지 모든 문자들은 리터럴로 간주된다.  
메타문자들도 메타문자로 인터프리트되는 대신에 확장되거나 리터럴로 처리될 수 있다.  


#### 앵커(Anchor)
정규표현식에서 ^(캐럿)은 행의 시작, $는 행의 끝을 의미하며 이들을 **앵커**라고 표현한다.


<br>
### 19.3. poxis 기본 VS 확장 정규 표현식
파이썬, R에서 정규표현식을 공부할 때 한 뭉터기로 배운 정규 표현식이  
유닉스 시스템에서는 둘로 나뉘는 개념이라는 것을 알게 되었다.  

기본 지원하던 정규 표현식을 BRE(Basic Regular Expression)이라고 하고,  
이후 추가된 정규 표현식을 ERE(Extended Regular Expression)이라고 한다.  

이 둘을 비교해보자.

범주| BRE | ERE
---|---|---
문자| ^ $ . [ ] * | ( ) { } ? + '|'|
사용 grep | grep | egrep(or grep -E)

( ) , { }은 BRE에서는 백슬래시가 항상 함께 쓰여야만 메타 문자로 인식되는 반면,  
ERE에서는 메타 문자 앞에 백슬래시 기호를 사용하게 되면 리터럴 문자를 의미함.

`echo "AAA" | greo -E 'AAA|BBB'`  
`echo "This works." | grep -E '[[:upper:][:upper:][:lower:]]*\.`  


260쪽
find에 -regex '_pattern_'을 통해 정규표현식을 통한 검색도 가능하다.  
locate는 --regex '_pattern_'  

또한 less과 vim 또한 정규표현식을 통한 검색을 지원하는데,  

less는 ERE를 사용해서 `/^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$` 처럼 전화번호를 찾을 수 있지만,  
vim은 BRE를 사용하기 때문에 `/^\([0-9]\{3\}\) [0-9]\{3\}-[0-9]\{4\}$`처럼 해주어야 한다.
<br><BR><BR>



## 20. 텍스트 편집

### 20.1. sort

옵션 | 설명
-----|----
-b |기본 sort는 각 줄의 첫 문자를 대상으로 하나 이 옵션은 각 줄의 공백 아닌 첫 문자 기준으로 정렬
-f | 대소문자 무시 정렬
-r | 역순
**-k**|**필드 전체가 아닌 키 필드 기준**
**-r** | **캐릭터가 아닌 숫자를 기준으로 정렬**
-t | 필드 구분 문자 설정
<br>

ex) 디렉토리의 최종 수정 시간을 기준으로 정렬해보자.  

`sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distrots.txt` 이와 같이 사용할 수 있다.  
<br>

### 20.2. uniq

* 옵션

옵션 | 설명
----|----
-c | 중복 발생 횟수와 중복 행의 목록을 출력
-d | 유일한 행이 아닌 중복된 행들만 출력
-f _n_ | 각 필드에서 _n_ 필드까지 무시한다.
-i | 대소문자 무무시
-s _n_ | 각 행의 _n_개의 문자까지 무시
-u | 유일한 행만 출력. __default__


### 텍스트 자르고 붙이기
### 20.3. cut
컷은 파일의 특정 필드나 문자열 부분만 잘라서 가져올 수 있는데,  
문자열 부분은 구분자를 지정할 수 없다.  

옵션 | 설명
----|----
-c  _char list_ | _char list_. 문자열 영역( `-`은 범위, `,`은 나열 )
-f  _field list_| _field list_ 자를 필드 영역. 위와 사용방법은 비슷.
-d _delim char_ | _delim char_ 필드를 구분할 구분자. **기본은 tab**
--complement | -c or(and) -f로 명시된 영역을 제외한 모든 부분을 추출

ex) ls의 롱버전에서 특정 필드만 제거하고 출력해보자.


#### 부록. 
기본적으로 cut은 필드는 tab으로 구분한다. 문자열은 그에 상응하는 스페이스로 구분.  
expand라는 프로그램으로 tab을 space로 바꿀 수 있다.(반대는 unexpand)
<br>

### 20.4. paste 행들을 붙이다.
파일에서 열을 추출하는 대신에 **파일에 하나 이상의 텍스트 열을 추가한다.**
<br>

### 20.5. join 공통 필드로 두 파일의 행을 합친다.
데이터베이스에서 공통된 필드를 기준으로 하나로 합치는 것이 `join`  
paste와의 차이점은 paste는 그냥 다 합치는 것에 비해, join은 공통된 필드가 있다면 중복하지 않는다.
<br><br>

### 신속한 편집
vim 등과 달리 비대화형 텍스트 편집기에 대해 알아보자.

### 20.5 tr : 문자 변환 또는 삭제
tr은 _transliterate_의 약자로 문자를 변환한다.  
표준 입력을 받아 변환하여 표준 출력으로 내보냄.  

`echo "lowercase letters" | tr a-z A-Z`  

* what if 두 문자열의 길이가 다르면?? 실험해보자.  

그리고 이상하게 책(289쪽)과는 달리 POSIX 문자 클래스는 적용되지 않는다.  

또한 `-d` 옵션을 통해 검색되는 조건을 삭제할 수 있다.  
예를 들어 dos 파일을 unix 파일로 변환하려면 `\r`, 즉 캐리지 리턴을 삭제해야 할 것이다.  

`tr -d '\r' dos-name unix-file-name`  

마지막으로 `-s` 옵션을 통해 반복되는 문자열을 압축할 수 있다.(아마 squeeze인듯)  
`echo "aaabbbaccc" | tr -s ab`
<br>

### 20.6 sed : 텍스트 필터링 & 변환
sed는 _stream editor_의 약자.  
텍스트 스트림과 명시된 파일 집합, 표준 입력 모두에서 텍스트 편집을 수행한다.  
매우 복잡하다고 함.(책까지..??)  

기본은 다음과 같다.

sed '_command_/_src_/_dst_/' 좀... 살펴볼까??  
아.. 참고로 `/`이 구분자는 `_` 등도 쓸 수 있다. 그러니까 임의의 구분자를 쓸 수 있다는 것.

* _command_
  - _command_는 한 글자. `s`는 치환을 의미한다.
  - `s` 앞에는 수정할 범위, 주소를 설정할 수 있다.
  - `1s` -> 1행만, `$` -> 마지막 행, `1-4s` -> 1행부터 4행까지, `3~ 4s` -> 3행부터 4행마다,  
    `3,+4s` -> 3행부터 4개만, `3!s` -> 3행을 제외하고


* src. 바꾸고 싶은 글자
* dst. 바꿀 글자.

이게 왜 안 될까?  
`echo Hi?|sed 's/?/!/'`
