#2장 환경과 설정 ~ 3장 기본 작업과 필수 도구

## 표준 파일 입출력
저번 스터디에서 한 내용을 악간 보충하도록 한다.  


c언어에서 표준 입출력에 대한 구현이 있는 곳은 바로 stdio.h이다.  
여기에 정의되어 있는 stdin, stdout, stderr과 FILE 매크로에 대해서 알아보도록 한다.  


파일의 정의는 이렇다. : 컴퓨터 파일(computer file)은 컴퓨터 등의 기기에서 의미 있는 정보를 담는 논리적인 단위이다.  


하드디스크, CD, DVD 등 저장매체에 대하여 추상화된 정보 단위이다. 운영체제는 파일 조작에 관련된 기능을 API로 제공한다.  
일반적으로 파일의 이름과 확장자로 식별하며, 운영 체제에 따라 대소문자를 구별하거나 구별하지 않는다.  


"파일"이라는 말은 1952년 일찍이 천공 카드에 저장된 정보를 가리키는 뜻으로 컴퓨터 기억 장치 환경에 나타났다.  
이용 초기에 사람들은 콘텐츠라기 보다는 뒷받침하는 하드웨어 자체를 가리키는 개념에서 파일이라는 용어를 사용하였다. 이를테면 IBM 350 디스크 드라이브는 "디스크 파일"이라고 불렸다.  
1962년의 CTSS(호환 시분할 시스템)와 같은 시스템은 여러 개의 파일들을 하나의 기억 장치에 제공하였던 파일 시스템을 선보였는데 이것이 현대의 용어로 자리잡게 한 주도적 역할을 하였다.   


(구글 번역기)  
	대부분의 최신 운영 체제에서 파일은 1 차원 바이트 배열로 구성됩니다.  
	파일 형식은 파일이 데이터의 컨테이너이기 때문에 내용에 따라 정의됩니다. 
	일부 플랫폼에서는 형식이 일반적으로 파일 이름 확장자로 표시되며 바이트를 체계적으로 구성하고 의미있게 해석해야하는 규칙을 지정합니다.  
	예를 들어 일반 텍스트 파일 (Windows의 경우 .txt)의 바이트는 ASCII 또는 UTF-8 문자와 연관되며 이미지, 비디오 및 오디오 파일의 바이트는 다른 방식으로 해석됩니다.  
	대부분의 파일 유형은 메타 데이터에 대해 몇 바이트를 할당하므로 파일이 자체에 대한 몇 가지 기본 정보를 전달할 수 있습니다.


	컴퓨터가 파일을 구성, 이름 지정, 저장 및 조작하는 방식은 대체로 파일 시스템이라 합니다.  
	대부분의 컴퓨터에는 최소한 하나의 파일 시스템이 있습니다.  
	- 위키백과  


	스트림을 이해하는데 도움이 될만한 정보 :  
	컴퓨터 과학에서 스트림은 시간이 흐르면서 사용 가능한 일련의 데이터 요소입니다. 스트림은 큰 배치가 아닌 한 번에 하나씩 처리되는 컨베이어 벨트의 항목으로 생각할 수 있습니다.  
	스트림은 일괄 처리 데이터와는 다르게 처리됩니다.  
	일반 함수는 잠재적으로 무제한 데이터를 가지며 전체적으로 스트림에서 작동 할 수 없으며 형식적으로 스트림은 데이터 (한정되지 않음)가 아니라 codata(잠재적으로 무제한)입니다.  
	스트림에서 작동하고 다른 스트림을 생성하는 기능은 필터로 알려져 있으며 기능 구성과 유사하게 파이프 라인으로 연결할 수 있습니다.  
	필터는 한 번에 스트림의 한 항목에서 작동하거나 이동 평균과 같은 여러 입력 항목에 출력 항목을 지정할 수 있습니다.  


	예를 들어, I/O 장치는 시간이 지남에 따라 잠재적으로 무제한의 데이터를 생성하거나 소비하므로 스트림으로 해석 될 수 있습니다.  
	C 프로그래밍 언어에 기반을 둔 유닉스 관련 시스템에서 스트림은 개별 바이트나 문자열인 데이터의 원천이다.  
	스트림들은 파일을 읽거나 쓸 때, 네트워크 소켓을 거쳐 통신할 때 쓰이는 추상적인 개념이다. 표준 스트림들은 모든 프로그램에 이용할 수 있는 세 개의 스트림을 말한다.  
	스트림 처리 - 병렬 처리, 특히 그래픽 처리에서 스트림이라는 용어는 소프트웨어는 물론 하드웨어에도 적용됩니다.  
	객체 지향 프로그래밍에서 입력 스트림은 대부분 반복자로 구현됩니다.  


	1. codata라는 용어가 나오는데 정확히 codata는 무엇인가? 적절한 정의를하기 전, 예를 들어보자. 

	스트림은 codata입니다.
	스트림이란 정확히 무엇인가? 스트림은 실행될 때 다음 중 하나를 생성하는 계산에 대한 참조입니다.

	논리적으로 시퀀스의 나머지 부분 인 다른 스트림 ("tail")과 함께 시퀀스의 첫 번째 요소 ("head")입니다.  
	또는...  
	시퀀스의 끝을 나타내는 특수 기호 ( "nil")입니다.  
	스트림(및 더 일반적으로 codata)은 계산 자체보다는 계산에 대한 참조이기 때문에 데이터입니다.  
	그러나 스트림 (및 더 일반적으로 codata)을 특수하게 만드는 것은 기본 계산이 실행될 때 다른 스트림 (더 일반적으로는 codata)을 생성 할 수 있다는 것입니다.  

	이제 나는 마침내 적절한 정의를 할 수 있습니다.  

	Codata는 실행될 때 더 많은 codata를 생성 할 수있는 계산에 대한 참조입니다.  

	바이트(비트)스트림 :  
	바이트 스트림은 일련의 바이트입니다. 일반적으로 각 바이트는 256 개의 고유 한 값 (옥텟)의 범위에 있으므로, 옥텟 스트림이라는 용어는 때로는 동일한 것을 가리키는 데 사용됩니다.  
	8 진수는 여러 가지 다른 방식으로 8 비트의 시퀀스로 인코딩 될 수 있으므로 (endianness 참조) 바이트 스트림과 바이트 스트림간에 고유하고 직접적인 변환은 없습니다.  
	비트 스트림과 바이트 스트림은 통신 및 컴퓨팅에서 광범위하게 사용됩니다. 예를 들어 동기식 디지털 계층 구조는 동기 비트 스트림을 전송하고 전송 제어 프로토콜은 비동기 바이트 스트림을 전송합니다.  

	형식적으로, 바이트 스트림은 특정 추상화로, 한 엔티티가 다른 끝의 엔티티에 일련의 바이트를 보낼 수있는 통신 채널입니다. 이러한 채널은 대개 양방향이지만 때로는 단방향입니다.  
	거의 모든 경우에 채널은 신뢰할 수있는 속성을 가지고 있습니다. 즉, 정확하게 동일한 바이트가 정확하게 동일한 순서로 다른 끝에 나타납니다.  
	덜 공식적으로, 그것을 두 개체 사이의 도관으로 생각할 수 있습니다. 하나의 엔티티는 도관에 바이트를 삽입 할 수 있고 다른 엔티티는 그 바이트를 수신합니다. 이 도관은 일시적이거나 영구적 일 수 있습니다.  

	예를 들어, Unix 계열 및 Windows를 포함한 대부분의 운영 체제에서 표준 I / O 라이브러리는 하위 수준의 페이징되거나 버퍼 된 파일 액세스를 bytestream 패러다임으로 변환합니다.  
	특히 유닉스 계열 운영 체제에서 각 프로세스에는 단방향 바이트 스트림의 예인 세 가지 표준 스트림이 있습니다. Unix 파이프 메커니즘은 서로 다른 프로세스간에 바이트 스트림 통신을 제공합니다.


	흔히 키보드 및 기타 주변 장치 (/ dev / tty)의 데이터, 의사 난수 생성기 / dev / urandom 등의 데이터와 같이 바이트 스트림의 내용이 동적으로 생성됩니다.  
	이러한 경우 바이트 스트림의 대상 (소비자)가 생성 할 수있는 것보다 더 빨리 바이트를 사용하면 시스템은 프로세스 동기화를 사용하여 다음 바이트가 사용 가능할 때까지 대상을 대기시킵니다.  
	바이트가 대상에서 사용할 수있는 것보다 빠르게 생성되면 상황을 처리 할 수있는 몇 가지 기술이 있습니다.  


	* 생산자가 소프트웨어 알고리즘 인 경우 시스템은 동일한 프로세스 동기화 기술을 사용하여 생산자를 일시 중지합니다.  
	* 생산자가 흐름 제어를 지원하면 시스템은 소비자가 다음 바이트를 준비 할 때 "준비"신호 만 전송합니다  
	* 제작자가 일시 중지 할 수없는 경우 (흐름 제어를 지원하지 않는 키보드 또는 일부 하드웨어) 시스템은 대개 이중 버퍼 또는 대기열을 사용하여 소비자가 준비 할 때까지 데이터를 임시로 저장하려고 시도합니다.  
	* 종종 수신기는 완전히 꽉 차기 전에 버퍼를 비울 수 있습니다. 버퍼가 가득차더라도 소비 할 수있는 것보다 빠르게 데이터를 생산하는 생산자는 원치 않는 버퍼 오버 플로우, 패킷 손실 및 네트워크 혼잡을 초래합니다.  


	자세한 예시: 키보드의 동작 원리  
	http://kylog.tistory.com/tag/%ED%82%A4%EB%B3%B4%EB%93%9C  


##리눅스의 _IO_FILE 정의

'''C  
	/* The opaque type of streams.  This is the definition used elsewhere.  */  
	typedef struct _IO_FILE FILE;   


	-> opaque(불투명) 내부 구현이 감춰져 있다는 뜻이다.  
	-> 파일 구조체에 대한 정의이다.  


	167 /* Standard streams.  */  
	168 extern struct _IO_FILE *stdin;      /* Standard input stream.  */  
	169 extern struct _IO_FILE *stdout;     /* Standard output stream.  */  
	170 extern struct _IO_FILE *stderr;     /* Standard error output stream.  */  
	171 /* C89/C99 say they're macros.  Make them happy.  */  
	172 #define stdin stdin  
	173 #define stdout stdout  
	174 #define stderr stderr  


	-> 이 정의에서 알 수 있는 점은 stdin, stdout, stderr은 파일이며, 파일 구조체의 "포인터"로 정의 되어 있다는 사실이다.  
	-> 또한 표준 스트림을 구현하는것은 OS에 달려있다는 사실도 알 수 있다.  

	// 여기는  libio.h에서 가져온 파일의 정의이다.
	// 파일 시스템에서의 파일과 파일 "핸들" 구조체는 다르다.
	// 정확하게 말하자면 파일"핸들" 구조체에 대한 정의
	// 파일 핸들은 프로세스와 프로세스 바깥의 I/O Connection에 대한 정의이다.
	struct _IO_FILE {
		int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags

		/* The following pointers correspond to the C++ streambuf protocol. */
		/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
		char* _IO_read_ptr;	/* Current read pointer */
		char* _IO_read_end;	/* End of get area. */
		char* _IO_read_base;	/* Start of putback+get area. */
		char* _IO_write_base;	/* Start of put area. */
		char* _IO_write_ptr;	/* Current put pointer. */
		char* _IO_write_end;	/* End of put area. */
		char* _IO_buf_base;	/* Start of reserve area. */
		char* _IO_buf_end;	/* End of reserve area. */
		/* The following fields are used to support backing up and undo. */
		char *_IO_save_base; /* Pointer to start of non-current get area. */
		char *_IO_backup_base;  /* Pointer to first valid character of backup area */
		char *_IO_save_end; /* Pointer to end of non-current get area. */

		struct _IO_marker *_markers;

		struct _IO_FILE *_chain;

		int _fileno;
#if 0
		int _blksize;
#else
		int _flags2;
#endif
		_IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
		/* 1+column number of pbase(); 0 is unknown. */
		unsigned short _cur_column;
		signed char _vtable_offset;
		char _shortbuf[1];

		/*  char* _save_gptr;  char* _save_egptr; */

		_IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
	};
'''

## 네트워크의 간략한 설명

### 용어 정리

1. 호스트 : 네트워크 자원의 소비자로 호스트 상에서 동작하는 응용 프로그램이야 말로 네트워크의 '실 사용자'라고 말 할 수 있다.
2. 라우터(게이트 웨이) : 통신 채널을 하나의 호스트에서 다른 통신 채널로 교체, 전달하는 일을 도맡은 장비이다.
3. 통신채널 : 하나의 호스트에서 또 다른 호스트로 일련의 바이트 집합을 전달하는 매개체이다.
4. 정보 : (컴퓨터 공학) 연속된 바이트로 이루어진 집합체로 프로그램에 의해 생성되고 이해된다.
5. 프로토콜 : 통신 프로그램 사이에서 교환되는 패킷에 대한 약속이자 정의이다. 프로토콜은 패킷이 어떻게 구성되어 있고 정보가 어떻게 이해되는지를 정의한다.
6. 데이터그램 : 인터넷 프로토콜은 데이터그램(datagram)서비스를 제공한다. 편지와 소포가 우편 시스템에 보내지는 것과 같이 모든 데이터그램(패킷)들은 네트워크에 의해 각각 독립적으로 다루어지고 전달이 된다.  

보충 설명 : 인터넷을 통해 전달되는 데이터는 데이터그램(datagram)이라고 불리는 일정한 크기의 패킷으로 전송된다.  
각각의 데이터그램은 헤더(header)와 페이로드(payload)를 포함하고 있다.  
헤더에는 수신할 곳의 주소와 포트, 패킷을 송신한 곳의 주소와 포트, 데이터 손상을 탐지하기 위한 체크섬, 그 밖에 신뢰할 수 있는 전송을 위해 필요한 정보들이 포함되어있다.  
페이로드에는 데이터 자체가 들어 있다.  


데이터그램과 스트림의 가장 큰 차이점을 말해보자면, 스트림은 연결이 되었다면 송신자가 전송한 데이터를 수신자가 '반드시' 받는 것을 보장한다.  
그러나 데이터그램(패킷)방식은 송신자는 데이터를 최선을 다해서 보내지만 수신자가 데이터를 받는다는 보장은 하지 못한다  
8. 종단 간 프로토콜 : IP가 어떤 호스트에서 다른 호스트로 데이터를 전달하는 것과 달리 TCP와 UDP는 프로그램에서 다른 프로그램으로 데이터를 전달한다. 이러한 의미에서 TCP와 UDP를 종단 간 전송 프로토콜이라고 부른다.
9. ipv4, ipv6 : 표준화된 두 개의 인터넷 프로토콜의 버전에 따라서 다른 특징을 가지는 두 가지 주소가 존재하는데, 그것이 바로 ipv4와 ipv6이다. 둘의 가장 큰 차이점은 ipv4는 32비트로 주소를 나타내고, ipv6는 128비트로 주소를 나타낸다.
10. 인터넷 주소, 포트 주소 : 인터넷 주소는 네트워크(인터넷 또는 IP) 계층에서 사용하는 인터넷 주소가 있고 TCP, UDP계층 또는 트랜스포트 계층이라고 불리는 계층에서 사용하는 포트 주소가 있다. 
11. 네트워크 인터페이스 : 기술적으로 IP주소는 하나의 호스트와 해당 호스트 하부에 존재하는 통신 채널, 즉 "네트워크 인터페이스"(network interface)사이에 존재하는 네트워크 연결을 의미한다.  
즉, IP주소는 네트워크 연결이다.  


네트워크 인터페이스는 컴퓨터 네트워크의 두 가지 장비 또는 프로토콜 계층 간의 시스템 (소프트웨어 및 / 또는 하드웨어) 인터페이스입니다.  
네트워크 인터페이스는 일반적으로 어떤 형태의 네트워크 주소를 갖습니다. 이것은 노드 ID와 포트 번호로 구성되거나 고유 한 노드 ID 일 수 있습니다.  
네트워크 인터페이스는 메시지 전달, 연결 및 연결 해제 등과 같은 표준화 된 기능을 제공합니다.  
12. ISP : Internet Service Provider  
13. 특별한 주소 Ex :  
루프백 인터페이스, 루프백 주소 : 전송한 패킷을 즉시 전송자에게 돌려보내는 기능을 가지는 가상의 디바이스를 루프백 인터페이스라고 한다.  
그리고 이를 위한 주소를 따로 할당해 두었는데 이것이 바로 루프백 주소이다. IPv4는 127.0.0.1로 할당 되어 있고 IPv6는 1로 할당되어 있다.  
14. NAT :  
네트워크 주소 변환(Network Address Translation, 줄여서 NAT)은 컴퓨터 네트워킹에서 쓰이는 용어로서, 
IP 패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술을 말한다.  
패킷에 변화가 생기기 때문에 IP나 TCP/UDP의 체크섬(checksum)도 다시 계산되어 재기록해야 한다.  


NAT를 이용하는 이유는 대개 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위함이다.   
많은 네트워크 관리자들이 NAT를 편리한 기법이라고 보고 널리 사용하고 있다. NAT가 호스트 간의 통신에 있어서 복잡성을 증가시킬 수 있으므로 네트워크 성능에 영향을 줄 수 있는 것은 당연하다.  
15. DHCP : (Dynamic Host Configuration Protocol, DHCP)는 호스트 IP 구성관리를 단순화하는 IP표준이다.  
동적 호스트 구성 프로토콜 표준에서는 DHCP 서버를 사용하여 IP주소 및 관련된 기타 세부 구성 정보를 네트워크의 DHCP 사용 클라이언트에세 동적으로 할당하는 방법으로 제공한다.  
또한 DHCP는 공유기의 자체 기능으로 들어있는 경우가 대부분이며 사용자 PC에도 설치 가능하다.  
16. 클라이언트와 서버 : 클라이언트와 서버 아키텍처  
서버: 수동적인 역할을 맡고 있으며 클라이언트가 서버에게 자원을 요청하면 해당 요청을 분석/처리하고 그 결과를 클라이언트에게 돌려준다.  
흔히 서버라고 지칭하는 존재는 서버 컴퓨터 또는 서버 프로그램을 이야기한다.    
서버 프로그램은 응용 프로그램이며 주로 데몬으로 구현되어있다.  
클라이언트 : 클라이언트는 서버에게 필요한 요청을 하고 그 결과를 돌려받아서 소모하는 역할을 한다. 클라이언트는 응용 프로그램을 지칭하는 경우가 많다.   
17. IANA : Internet Assigned Number Authority 포트 번호 등을 관리한다.  
18. 서번트 : 서버와 클라이언트를 합쳐서 서번트라고 부르기도 한다.  
19. 소켓 : 컴퓨터의 네트워크 자원을 쉽게 얻기 위해 만든 API(주로 C로 작성되어 있다.)
또는 응용 프로그램이 이를 통해 데이터를 송수신할 수 있는 추상화된 개념으로, 응용 프로그램이 저장 매체에 파일을 읽고 쓰기 위해서 사용하는 파일 핸들러와 매우 흡사하다.  
20. TCP : 운영체제 내부 구현으로 이루어져 있다. + (Transmission control protocol) 호스트간 신뢰성 있는 데이터 전달과 흐름제어 및 혼잡제어 등을 제공하는 전송 계층이며 인터넷 환경에서 기본으로 사용한다.  
21. UDP : 운영체제 내부 구현으로 이루어져 있다. + (User Datagram Protocol) 보내는 쪽에서는 받는 쪽이 데이터를 받았는지 받지 않았는지 확인할 수 없고,  
	또 확인할 필요도 없도록 만들어진 프로토콜이며, 신뢰성을 확보하기 위해서는 사용자가 알아서 처리해 주어야 한다.   
22. IP : 운영체제 내부 구현으로 이루어져 있다. + IP의 정보는 패킷 혹은 데이터그램이라고 하는 덩어리로 나뉘어 전송된다.  
IP에서는 이전에 통신한 적 없는 호스트에 패킷을 보낼 때 경로 설정이 필요없다.   


## 프로세스

1. 프로세스의 정의  
1-1: 현재 실행 중인 프로그램
1-2: 프로세스는 프로그램을 실행하기 위해서 자원이 할당된, 커널이 정의한 추상적인 존재다.  
1-3: 프로세스의 특징을 잘 생각해보면, '개체 entity'로 구분할 수 있다는 사실을 알 수 있고, 그 중에서도 활성화된 개체라고 이해 할 수 있다.  
1-4: 한마디로 말해서 프로세스는 '일'(물리의 일 아님) '작업' '활동'과 같은 논리적인 단위라고 할 수 있다.  


2. 프로그램의 정의  
2-1: 실행가능한 파일  
2-2: 실행시에 프로세스를 어떻게 만들지에 대한 광범위한 정보를 담고 있는 파일이다.  
2-3: 프로그램은 일반적으로 보조 기억장치등에 저장되어 있는 실행 코드를 뜻하고, 프로세스는 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위를 지칭한다.  
예를 들어서 하나의 프로그램을 여러번 구동하면 여러개의 프로세스가 메모리 상에서 실행된다.  

3. 프로세서의 정의
 3-1: 프로세서는 CPU이다.  
 3-2: 프로세서는 외부에서 정보를 입력 받고, 기억하고, 컴퓨터 프로그램의 명령어를 해석하여 연산하고, 외부로 출력하는 역할을 한다.  
따라서 중앙 처리 장치(CPU)는 컴퓨터 부품과 정보를 교환하면서 컴퓨터 시스템 전체를 제어하는 장치로,  
모든 컴퓨터의 작동과정이 중앙 처리 장치(CPU)의 제어를 받기 때문에 컴퓨터의 두뇌에 해당한다고 할 수 있다.  
실제의 CPU 칩엔 실행 부분뿐만 아니라 캐시 등의 부가 장치가 통합된 경우가 많다.  
 3-3: 정의에서도 알 수 있듯이 프로세서는 외부에서 (또는 내장된 메모리 등에서) 명령어를 받아들여 처리하는 행동만 할 뿐이다.  
 따라서 이를 사람이 쉽게 구분하고 다루는 단위를 프로세스, 스레드 등으로 나눈것이라 볼 수 있겠다.  

